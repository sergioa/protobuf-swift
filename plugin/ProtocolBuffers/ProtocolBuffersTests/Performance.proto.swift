// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "performance.proto"
// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public func == (lhs: PBUser, rhs: PBUser) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasGroup == rhs.hasGroup) && (!lhs.hasGroup || lhs.group == rhs.group)
  fieldCheck = fieldCheck && (lhs.hasGroupName == rhs.hasGroupName) && (!lhs.hasGroupName || lhs.groupName == rhs.groupName)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PBGroup, rhs: PBGroup) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasOwner == rhs.hasOwner) && (!lhs.hasOwner || lhs.owner == rhs.owner)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PBPerfomanceBatch, rhs: PBPerfomanceBatch) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.batch == rhs.batch)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PBPerfomance, rhs: PBPerfomance) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasInts == rhs.hasInts) && (!lhs.hasInts || lhs.ints == rhs.ints)
  fieldCheck = fieldCheck && (lhs.hasInts64 == rhs.hasInts64) && (!lhs.hasInts64 || lhs.ints64 == rhs.ints64)
  fieldCheck = fieldCheck && (lhs.hasDoubles == rhs.hasDoubles) && (!lhs.hasDoubles || lhs.doubles == rhs.doubles)
  fieldCheck = fieldCheck && (lhs.hasFloats == rhs.hasFloats) && (!lhs.hasFloats || lhs.floats == rhs.floats)
  fieldCheck = fieldCheck && (lhs.hasStr == rhs.hasStr) && (!lhs.hasStr || lhs.str == rhs.str)
  fieldCheck = fieldCheck && (lhs.hasBytes == rhs.hasBytes) && (!lhs.hasBytes || lhs.bytes == rhs.bytes)
  fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PBProtoPoint, rhs: PBProtoPoint) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PBIceCreamCone, rhs: PBIceCreamCone) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasScoops == rhs.hasScoops) && (!lhs.hasScoops || lhs.scoops == rhs.scoops)
  fieldCheck = fieldCheck && (lhs.hasFlavor == rhs.hasFlavor) && (!lhs.hasFlavor || lhs.flavor == rhs.flavor)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PBFoo, rhs: PBFoo) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVal == rhs.hasVal) && (!lhs.hasVal || lhs.val == rhs.val)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PBBar, rhs: PBBar) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFoo == rhs.hasFoo) && (!lhs.hasFoo || lhs.foo == rhs.foo)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PBBaz, rhs: PBBaz) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBar == rhs.hasBar) && (!lhs.hasBar || lhs.bar == rhs.bar)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public struct PerformanceRoot {
  public static var sharedInstance : PerformanceRoot {
   struct Static {
       static let instance : PerformanceRoot = PerformanceRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(registry: extensionRegistry)
    Google.Protobuf.SwiftDescriptorRoot.sharedInstance.registerAllExtensions(registry: extensionRegistry)
  }
  public func registerAllExtensions(registry: ExtensionRegistry) {
  }
}

final public class PBUser : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var group:PBGroup!
  public private(set) var hasGroup:Bool = false
  public private(set) var groupName:String = ""

  public private(set) var hasGroupName:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream: CodedOutputStream) throws {
    if hasGroup {
      try codedOutputStream.writeMessage(fieldNumber: 1, value:group)
    }
    if hasGroupName {
      try codedOutputStream.writeString(fieldNumber: 2, value:groupName)
    }
    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasGroup {
        if let varSizegroup = group?.computeMessageSize(fieldNumber: 1) {
            serialize_size += varSizegroup
        }
    }
    if hasGroupName {
      serialize_size += groupName.computeStringSize(fieldNumber: 2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBUser> {
    var mergedArray = Array<PBUser>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> PBUser? {
    return try PBUser.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> PBUser {
    return try PBUser.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBUser {
    return try PBUser.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> PBUser {
    return try PBUser.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBUser {
    return try PBUser.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> PBUser {
    return try PBUser.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBUser {
    return try PBUser.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBUser.Builder {
    return PBUser.classBuilder() as! PBUser.Builder
  }
  public func getBuilder() -> PBUser.Builder {
    return classBuilder() as! PBUser.Builder
  }
  override public class func classBuilder() -> MessageBuilder {
    return PBUser.Builder()
  }
  override public func classBuilder() -> MessageBuilder {
    return PBUser.Builder()
  }
  public func toBuilder() throws -> PBUser.Builder {
    return try PBUser.builderWithPrototype(prototype:self)
  }
  public class func builderWithPrototype(prototype:PBUser) throws -> PBUser.Builder {
    return try PBUser.Builder().mergeFrom(other:prototype)
  }
  override public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasGroup {
      jsonMap["group"] = try group.encode()
    }
    if hasGroupName {
      jsonMap["groupName"] = groupName
    }
    return jsonMap
  }
  override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> PBUser {
    return try PBUser.Builder.decodeToBuilder(jsonMap:jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> PBUser {
    return try PBUser.Builder.fromJSONToBuilder(data:data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasGroup {
      output += "\(indent) group {\n"
      if let outDescGroup = group {
        output += try outDescGroup.getDescription(indent: "\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasGroupName {
      output += "\(indent) groupName: \(groupName) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasGroup {
              if let hashValuegroup = group?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuegroup
              }
          }
          if hasGroupName {
             hashCode = (hashCode &* 31) &+ groupName.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBUser"
  }
  override public func className() -> String {
      return "PBUser"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBUser.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBUser = PBUser()
    public func getMessage() -> PBUser {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasGroup:Bool {
         get {
             return builderResult.hasGroup
         }
    }
    public var group:PBGroup! {
         get {
             if groupBuilder_ != nil {
                builderResult.group = groupBuilder_.getMessage()
             }
             return builderResult.group
         }
         set (value) {
             builderResult.hasGroup = true
             builderResult.group = value
         }
    }
    private var groupBuilder_:PBGroup.Builder! {
         didSet {
            builderResult.hasGroup = true
         }
    }
    public func getGroupBuilder() -> PBGroup.Builder {
      if groupBuilder_ == nil {
         groupBuilder_ = PBGroup.Builder()
         builderResult.group = groupBuilder_.getMessage()
         if group != nil {
            _ = try! groupBuilder_.mergeFrom(other: group)
         }
      }
      return groupBuilder_
    }
    public func setGroup(_ value:PBGroup!) -> PBUser.Builder {
      self.group = value
      return self
    }
    public func mergeGroup(value:PBGroup) throws -> PBUser.Builder {
      if builderResult.hasGroup {
        builderResult.group = try PBGroup.builderWithPrototype(prototype:builderResult.group).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.group = value
      }
      builderResult.hasGroup = true
      return self
    }
    public func clearGroup() -> PBUser.Builder {
      groupBuilder_ = nil
      builderResult.hasGroup = false
      builderResult.group = nil
      return self
    }
    public var hasGroupName:Bool {
         get {
              return builderResult.hasGroupName
         }
    }
    public var groupName:String {
         get {
              return builderResult.groupName
         }
         set (value) {
             builderResult.hasGroupName = true
             builderResult.groupName = value
         }
    }
    public func setGroupName(_ value:String) -> PBUser.Builder {
      self.groupName = value
      return self
    }
    public func clearGroupName() -> PBUser.Builder{
         builderResult.hasGroupName = false
         builderResult.groupName = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> PBUser.Builder {
      builderResult = PBUser()
      return self
    }
    override public func clone() throws -> PBUser.Builder {
      return try PBUser.builderWithPrototype(prototype:builderResult)
    }
    override public func build() throws -> PBUser {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBUser {
      let returnMe:PBUser = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBUser) throws -> PBUser.Builder {
      if other == PBUser() {
       return self
      }
      if (other.hasGroup) {
          _ = try mergeGroup(value: other.group)
      }
      if other.hasGroupName {
           groupName = other.groupName
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PBUser.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBUser.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:PBGroup.Builder = PBGroup.Builder()
          if hasGroup {
            _ = try subBuilder.mergeFrom(other: group)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          group = subBuilder.buildPartial()

        case 18:
          groupName = try codedInputStream.readString()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> PBUser.Builder {
      let resultDecodedBuilder = PBUser.Builder()
      if let jsonValueGroup = jsonMap["group"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.group = try PBGroup.Builder.decodeToBuilder(jsonMap:jsonValueGroup).build()

      }
      if let jsonValueGroupName = jsonMap["groupName"] as? String {
        resultDecodedBuilder.groupName = jsonValueGroupName
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> PBUser.Builder {
      let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try PBUser.Builder.decodeToBuilder(jsonMap:jsDataCast)
    }
  }

}

final public class PBGroup : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var owner:PBUser!
  public private(set) var hasOwner:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream: CodedOutputStream) throws {
    if hasOwner {
      try codedOutputStream.writeMessage(fieldNumber: 1, value:owner)
    }
    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasOwner {
        if let varSizeowner = owner?.computeMessageSize(fieldNumber: 1) {
            serialize_size += varSizeowner
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBGroup> {
    var mergedArray = Array<PBGroup>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> PBGroup? {
    return try PBGroup.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> PBGroup {
    return try PBGroup.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBGroup {
    return try PBGroup.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> PBGroup {
    return try PBGroup.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBGroup {
    return try PBGroup.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> PBGroup {
    return try PBGroup.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBGroup {
    return try PBGroup.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBGroup.Builder {
    return PBGroup.classBuilder() as! PBGroup.Builder
  }
  public func getBuilder() -> PBGroup.Builder {
    return classBuilder() as! PBGroup.Builder
  }
  override public class func classBuilder() -> MessageBuilder {
    return PBGroup.Builder()
  }
  override public func classBuilder() -> MessageBuilder {
    return PBGroup.Builder()
  }
  public func toBuilder() throws -> PBGroup.Builder {
    return try PBGroup.builderWithPrototype(prototype:self)
  }
  public class func builderWithPrototype(prototype:PBGroup) throws -> PBGroup.Builder {
    return try PBGroup.Builder().mergeFrom(other:prototype)
  }
  override public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasOwner {
      jsonMap["owner"] = try owner.encode()
    }
    return jsonMap
  }
  override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> PBGroup {
    return try PBGroup.Builder.decodeToBuilder(jsonMap:jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> PBGroup {
    return try PBGroup.Builder.fromJSONToBuilder(data:data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasOwner {
      output += "\(indent) owner {\n"
      if let outDescOwner = owner {
        output += try outDescOwner.getDescription(indent: "\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasOwner {
              if let hashValueowner = owner?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueowner
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBGroup"
  }
  override public func className() -> String {
      return "PBGroup"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBGroup.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBGroup = PBGroup()
    public func getMessage() -> PBGroup {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasOwner:Bool {
         get {
             return builderResult.hasOwner
         }
    }
    public var owner:PBUser! {
         get {
             if ownerBuilder_ != nil {
                builderResult.owner = ownerBuilder_.getMessage()
             }
             return builderResult.owner
         }
         set (value) {
             builderResult.hasOwner = true
             builderResult.owner = value
         }
    }
    private var ownerBuilder_:PBUser.Builder! {
         didSet {
            builderResult.hasOwner = true
         }
    }
    public func getOwnerBuilder() -> PBUser.Builder {
      if ownerBuilder_ == nil {
         ownerBuilder_ = PBUser.Builder()
         builderResult.owner = ownerBuilder_.getMessage()
         if owner != nil {
            _ = try! ownerBuilder_.mergeFrom(other: owner)
         }
      }
      return ownerBuilder_
    }
    public func setOwner(_ value:PBUser!) -> PBGroup.Builder {
      self.owner = value
      return self
    }
    public func mergeOwner(value:PBUser) throws -> PBGroup.Builder {
      if builderResult.hasOwner {
        builderResult.owner = try PBUser.builderWithPrototype(prototype:builderResult.owner).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.owner = value
      }
      builderResult.hasOwner = true
      return self
    }
    public func clearOwner() -> PBGroup.Builder {
      ownerBuilder_ = nil
      builderResult.hasOwner = false
      builderResult.owner = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> PBGroup.Builder {
      builderResult = PBGroup()
      return self
    }
    override public func clone() throws -> PBGroup.Builder {
      return try PBGroup.builderWithPrototype(prototype:builderResult)
    }
    override public func build() throws -> PBGroup {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBGroup {
      let returnMe:PBGroup = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBGroup) throws -> PBGroup.Builder {
      if other == PBGroup() {
       return self
      }
      if (other.hasOwner) {
          _ = try mergeOwner(value: other.owner)
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PBGroup.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBGroup.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:PBUser.Builder = PBUser.Builder()
          if hasOwner {
            _ = try subBuilder.mergeFrom(other: owner)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          owner = subBuilder.buildPartial()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> PBGroup.Builder {
      let resultDecodedBuilder = PBGroup.Builder()
      if let jsonValueOwner = jsonMap["owner"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.owner = try PBUser.Builder.decodeToBuilder(jsonMap:jsonValueOwner).build()

      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> PBGroup.Builder {
      let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try PBGroup.Builder.decodeToBuilder(jsonMap:jsDataCast)
    }
  }

}

final public class PBPerfomanceBatch : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var batch:Array<PBPerfomance>  = Array<PBPerfomance>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitBatch:Bool = true
    for oneElementBatch in batch {
      if !oneElementBatch.isInitialized() {
        isInitBatch = false
        break 
      }
    }
    if !isInitBatch {
      return isInitBatch
    }
   return true
  }
  override public func writeTo(codedOutputStream: CodedOutputStream) throws {
    for oneElementBatch in batch {
        try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementBatch)
    }
    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementBatch in batch {
        serialize_size += oneElementBatch.computeMessageSize(fieldNumber: 1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBPerfomanceBatch> {
    var mergedArray = Array<PBPerfomanceBatch>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> PBPerfomanceBatch? {
    return try PBPerfomanceBatch.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBPerfomanceBatch.Builder {
    return PBPerfomanceBatch.classBuilder() as! PBPerfomanceBatch.Builder
  }
  public func getBuilder() -> PBPerfomanceBatch.Builder {
    return classBuilder() as! PBPerfomanceBatch.Builder
  }
  override public class func classBuilder() -> MessageBuilder {
    return PBPerfomanceBatch.Builder()
  }
  override public func classBuilder() -> MessageBuilder {
    return PBPerfomanceBatch.Builder()
  }
  public func toBuilder() throws -> PBPerfomanceBatch.Builder {
    return try PBPerfomanceBatch.builderWithPrototype(prototype:self)
  }
  public class func builderWithPrototype(prototype:PBPerfomanceBatch) throws -> PBPerfomanceBatch.Builder {
    return try PBPerfomanceBatch.Builder().mergeFrom(other:prototype)
  }
  override public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if !batch.isEmpty {
      var jsonArrayBatch:Array<Dictionary<String,AnyObject>> = []
        for oneValueBatch in batch {
          let ecodedMessageBatch = try oneValueBatch.encode()
          jsonArrayBatch.append(ecodedMessageBatch)
        }
      jsonMap["batch"] = jsonArrayBatch
    }
    return jsonMap
  }
  override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder.decodeToBuilder(jsonMap:jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder.fromJSONToBuilder(data:data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    var batchElementIndex:Int = 0
    for oneElementBatch in batch {
        output += "\(indent) batch[\(batchElementIndex)] {\n"
        output += try oneElementBatch.getDescription(indent: "\(indent)  ")
        output += "\(indent)}\n"
        batchElementIndex += 1
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementBatch in batch {
              hashCode = (hashCode &* 31) &+ oneElementBatch.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBPerfomanceBatch"
  }
  override public func className() -> String {
      return "PBPerfomanceBatch"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBPerfomanceBatch.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBPerfomanceBatch = PBPerfomanceBatch()
    public func getMessage() -> PBPerfomanceBatch {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var batch:Array<PBPerfomance> {
         get {
             return builderResult.batch
         }
         set (value) {
             builderResult.batch = value
         }
    }
    public func setBatch(_ value:Array<PBPerfomance>) -> PBPerfomanceBatch.Builder {
      self.batch = value
      return self
    }
    public func clearBatch() -> PBPerfomanceBatch.Builder {
      builderResult.batch.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> PBPerfomanceBatch.Builder {
      builderResult = PBPerfomanceBatch()
      return self
    }
    override public func clone() throws -> PBPerfomanceBatch.Builder {
      return try PBPerfomanceBatch.builderWithPrototype(prototype:builderResult)
    }
    override public func build() throws -> PBPerfomanceBatch {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBPerfomanceBatch {
      let returnMe:PBPerfomanceBatch = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBPerfomanceBatch) throws -> PBPerfomanceBatch.Builder {
      if other == PBPerfomanceBatch() {
       return self
      }
      if !other.batch.isEmpty  {
         builderResult.batch += other.batch
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PBPerfomanceBatch.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomanceBatch.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder = PBPerfomance.Builder()
          try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
          batch.append(subBuilder.buildPartial())

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> PBPerfomanceBatch.Builder {
      let resultDecodedBuilder = PBPerfomanceBatch.Builder()
      if let jsonValueBatch = jsonMap["batch"] as? Array<Dictionary<String,AnyObject>> {
        var jsonArrayBatch:Array<PBPerfomance> = []
        for oneValueBatch in jsonValueBatch {
          let messageFromStringBatch = try PBPerfomance.Builder.decodeToBuilder(jsonMap:oneValueBatch).build()

          jsonArrayBatch.append(messageFromStringBatch)
        }
        resultDecodedBuilder.batch = jsonArrayBatch
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> PBPerfomanceBatch.Builder {
      let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try PBPerfomanceBatch.Builder.decodeToBuilder(jsonMap:jsDataCast)
    }
  }

}

final public class PBPerfomance : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var ints:Int32 = Int32(0)

  public private(set) var hasInts:Bool = false
  public private(set) var ints64:Int64 = Int64(0)

  public private(set) var hasInts64:Bool = false
  public private(set) var doubles:Double = Double(0)

  public private(set) var hasDoubles:Bool = false
  public private(set) var floats:Float = Float(0)

  public private(set) var hasFloats:Bool = false
  public private(set) var str:String = ""

  public private(set) var hasStr:Bool = false
  public private(set) var bytes:Data = Data()

  public private(set) var hasBytes:Bool = false
  public private(set) var description_:String = ""

  public private(set) var hasDescription:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasInts {
      return false
    }
    if !hasInts64 {
      return false
    }
    if !hasDoubles {
      return false
    }
    if !hasFloats {
      return false
    }
   return true
  }
  override public func writeTo(codedOutputStream: CodedOutputStream) throws {
    if hasInts {
      try codedOutputStream.writeInt32(fieldNumber: 1, value:ints)
    }
    if hasInts64 {
      try codedOutputStream.writeInt64(fieldNumber: 2, value:ints64)
    }
    if hasDoubles {
      try codedOutputStream.writeDouble(fieldNumber: 3, value:doubles)
    }
    if hasFloats {
      try codedOutputStream.writeFloat(fieldNumber: 4, value:floats)
    }
    if hasStr {
      try codedOutputStream.writeString(fieldNumber: 5, value:str)
    }
    if hasBytes {
      try codedOutputStream.writeData(fieldNumber: 6, value:bytes)
    }
    if hasDescription {
      try codedOutputStream.writeString(fieldNumber: 7, value:description_)
    }
    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasInts {
      serialize_size += ints.computeInt32Size(fieldNumber: 1)
    }
    if hasInts64 {
      serialize_size += ints64.computeInt64Size(fieldNumber: 2)
    }
    if hasDoubles {
      serialize_size += doubles.computeDoubleSize(fieldNumber: 3)
    }
    if hasFloats {
      serialize_size += floats.computeFloatSize(fieldNumber: 4)
    }
    if hasStr {
      serialize_size += str.computeStringSize(fieldNumber: 5)
    }
    if hasBytes {
      serialize_size += bytes.computeDataSize(fieldNumber: 6)
    }
    if hasDescription {
      serialize_size += description_.computeStringSize(fieldNumber: 7)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBPerfomance> {
    var mergedArray = Array<PBPerfomance>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> PBPerfomance? {
    return try PBPerfomance.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> PBPerfomance {
    return try PBPerfomance.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBPerfomance {
    return try PBPerfomance.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> PBPerfomance {
    return try PBPerfomance.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomance {
    return try PBPerfomance.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> PBPerfomance {
    return try PBPerfomance.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomance {
    return try PBPerfomance.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBPerfomance.Builder {
    return PBPerfomance.classBuilder() as! PBPerfomance.Builder
  }
  public func getBuilder() -> PBPerfomance.Builder {
    return classBuilder() as! PBPerfomance.Builder
  }
  override public class func classBuilder() -> MessageBuilder {
    return PBPerfomance.Builder()
  }
  override public func classBuilder() -> MessageBuilder {
    return PBPerfomance.Builder()
  }
  public func toBuilder() throws -> PBPerfomance.Builder {
    return try PBPerfomance.builderWithPrototype(prototype:self)
  }
  public class func builderWithPrototype(prototype:PBPerfomance) throws -> PBPerfomance.Builder {
    return try PBPerfomance.Builder().mergeFrom(other:prototype)
  }
  override public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasInts {
      jsonMap["ints"] = NSNumber(value:ints)
    }
    if hasInts64 {
      jsonMap["ints64"] = "\(ints64)"
    }
    if hasDoubles {
      jsonMap["doubles"] = NSNumber(value:doubles)
    }
    if hasFloats {
      jsonMap["floats"] = NSNumber(value:floats)
    }
    if hasStr {
      jsonMap["str"] = str
    }
    if hasBytes {
      jsonMap["bytes"] = bytes.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
    }
    if hasDescription {
      jsonMap["description"] = description_
    }
    return jsonMap
  }
  override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> PBPerfomance {
    return try PBPerfomance.Builder.decodeToBuilder(jsonMap:jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> PBPerfomance {
    return try PBPerfomance.Builder.fromJSONToBuilder(data:data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasInts {
      output += "\(indent) ints: \(ints) \n"
    }
    if hasInts64 {
      output += "\(indent) ints64: \(ints64) \n"
    }
    if hasDoubles {
      output += "\(indent) doubles: \(doubles) \n"
    }
    if hasFloats {
      output += "\(indent) floats: \(floats) \n"
    }
    if hasStr {
      output += "\(indent) str: \(str) \n"
    }
    if hasBytes {
      output += "\(indent) bytes: \(bytes) \n"
    }
    if hasDescription {
      output += "\(indent) description_: \(description_) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasInts {
             hashCode = (hashCode &* 31) &+ ints.hashValue
          }
          if hasInts64 {
             hashCode = (hashCode &* 31) &+ ints64.hashValue
          }
          if hasDoubles {
             hashCode = (hashCode &* 31) &+ doubles.hashValue
          }
          if hasFloats {
             hashCode = (hashCode &* 31) &+ floats.hashValue
          }
          if hasStr {
             hashCode = (hashCode &* 31) &+ str.hashValue
          }
          if hasBytes {
             hashCode = (hashCode &* 31) &+ bytes.hashValue
          }
          if hasDescription {
             hashCode = (hashCode &* 31) &+ description_.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBPerfomance"
  }
  override public func className() -> String {
      return "PBPerfomance"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBPerfomance.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBPerfomance = PBPerfomance()
    public func getMessage() -> PBPerfomance {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasInts:Bool {
         get {
              return builderResult.hasInts
         }
    }
    public var ints:Int32 {
         get {
              return builderResult.ints
         }
         set (value) {
             builderResult.hasInts = true
             builderResult.ints = value
         }
    }
    public func setInts(_ value:Int32) -> PBPerfomance.Builder {
      self.ints = value
      return self
    }
    public func clearInts() -> PBPerfomance.Builder{
         builderResult.hasInts = false
         builderResult.ints = Int32(0)
         return self
    }
    public var hasInts64:Bool {
         get {
              return builderResult.hasInts64
         }
    }
    public var ints64:Int64 {
         get {
              return builderResult.ints64
         }
         set (value) {
             builderResult.hasInts64 = true
             builderResult.ints64 = value
         }
    }
    public func setInts64(_ value:Int64) -> PBPerfomance.Builder {
      self.ints64 = value
      return self
    }
    public func clearInts64() -> PBPerfomance.Builder{
         builderResult.hasInts64 = false
         builderResult.ints64 = Int64(0)
         return self
    }
    public var hasDoubles:Bool {
         get {
              return builderResult.hasDoubles
         }
    }
    public var doubles:Double {
         get {
              return builderResult.doubles
         }
         set (value) {
             builderResult.hasDoubles = true
             builderResult.doubles = value
         }
    }
    public func setDoubles(_ value:Double) -> PBPerfomance.Builder {
      self.doubles = value
      return self
    }
    public func clearDoubles() -> PBPerfomance.Builder{
         builderResult.hasDoubles = false
         builderResult.doubles = Double(0)
         return self
    }
    public var hasFloats:Bool {
         get {
              return builderResult.hasFloats
         }
    }
    public var floats:Float {
         get {
              return builderResult.floats
         }
         set (value) {
             builderResult.hasFloats = true
             builderResult.floats = value
         }
    }
    public func setFloats(_ value:Float) -> PBPerfomance.Builder {
      self.floats = value
      return self
    }
    public func clearFloats() -> PBPerfomance.Builder{
         builderResult.hasFloats = false
         builderResult.floats = Float(0)
         return self
    }
    public var hasStr:Bool {
         get {
              return builderResult.hasStr
         }
    }
    public var str:String {
         get {
              return builderResult.str
         }
         set (value) {
             builderResult.hasStr = true
             builderResult.str = value
         }
    }
    public func setStr(_ value:String) -> PBPerfomance.Builder {
      self.str = value
      return self
    }
    public func clearStr() -> PBPerfomance.Builder{
         builderResult.hasStr = false
         builderResult.str = ""
         return self
    }
    public var hasBytes:Bool {
         get {
              return builderResult.hasBytes
         }
    }
    public var bytes:Data {
         get {
              return builderResult.bytes
         }
         set (value) {
             builderResult.hasBytes = true
             builderResult.bytes = value
         }
    }
    public func setBytes(_ value:Data) -> PBPerfomance.Builder {
      self.bytes = value
      return self
    }
    public func clearBytes() -> PBPerfomance.Builder{
         builderResult.hasBytes = false
         builderResult.bytes = Data()
         return self
    }
    public var hasDescription:Bool {
         get {
              return builderResult.hasDescription
         }
    }
    public var description_:String {
         get {
              return builderResult.description_
         }
         set (value) {
             builderResult.hasDescription = true
             builderResult.description_ = value
         }
    }
    public func setDescription(_ value:String) -> PBPerfomance.Builder {
      self.description_ = value
      return self
    }
    public func clearDescription() -> PBPerfomance.Builder{
         builderResult.hasDescription = false
         builderResult.description_ = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> PBPerfomance.Builder {
      builderResult = PBPerfomance()
      return self
    }
    override public func clone() throws -> PBPerfomance.Builder {
      return try PBPerfomance.builderWithPrototype(prototype:builderResult)
    }
    override public func build() throws -> PBPerfomance {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBPerfomance {
      let returnMe:PBPerfomance = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBPerfomance) throws -> PBPerfomance.Builder {
      if other == PBPerfomance() {
       return self
      }
      if other.hasInts {
           ints = other.ints
      }
      if other.hasInts64 {
           ints64 = other.ints64
      }
      if other.hasDoubles {
           doubles = other.doubles
      }
      if other.hasFloats {
           floats = other.floats
      }
      if other.hasStr {
           str = other.str
      }
      if other.hasBytes {
           bytes = other.bytes
      }
      if other.hasDescription {
           description_ = other.description_
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PBPerfomance.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomance.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          ints = try codedInputStream.readInt32()

        case 16:
          ints64 = try codedInputStream.readInt64()

        case 25:
          doubles = try codedInputStream.readDouble()

        case 37:
          floats = try codedInputStream.readFloat()

        case 42:
          str = try codedInputStream.readString()

        case 50:
          bytes = try codedInputStream.readData()

        case 58:
          description_ = try codedInputStream.readString()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> PBPerfomance.Builder {
      let resultDecodedBuilder = PBPerfomance.Builder()
      if let jsonValueInts = jsonMap["ints"] as? NSNumber {
        resultDecodedBuilder.ints = jsonValueInts.int32Value
      }
      if let jsonValueInts64 = jsonMap["ints64"] as? String {
        resultDecodedBuilder.ints64 = Int64(jsonValueInts64)!
      }
      if let jsonValueDoubles = jsonMap["doubles"] as? NSNumber {
        resultDecodedBuilder.doubles = jsonValueDoubles.doubleValue
      }
      if let jsonValueFloats = jsonMap["floats"] as? NSNumber {
        resultDecodedBuilder.floats = jsonValueFloats.floatValue
      }
      if let jsonValueStr = jsonMap["str"] as? String {
        resultDecodedBuilder.str = jsonValueStr
      }
      if let jsonValueBytes = jsonMap["bytes"] as? String {
        resultDecodedBuilder.bytes = Data(base64Encoded:jsonValueBytes, options: Data.Base64DecodingOptions(rawValue:0))!
      }
      if let jsonValueDescription = jsonMap["description"] as? String {
        resultDecodedBuilder.description_ = jsonValueDescription
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> PBPerfomance.Builder {
      let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try PBPerfomance.Builder.decodeToBuilder(jsonMap:jsDataCast)
    }
  }

}

final public class PBProtoPoint : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var latitude:Float = Float(0)

  public private(set) var hasLatitude:Bool = false
  public private(set) var longitude:Float = Float(0)

  public private(set) var hasLongitude:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasLatitude {
      return false
    }
    if !hasLongitude {
      return false
    }
   return true
  }
  override public func writeTo(codedOutputStream: CodedOutputStream) throws {
    if hasLatitude {
      try codedOutputStream.writeFloat(fieldNumber: 1, value:latitude)
    }
    if hasLongitude {
      try codedOutputStream.writeFloat(fieldNumber: 2, value:longitude)
    }
    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasLatitude {
      serialize_size += latitude.computeFloatSize(fieldNumber: 1)
    }
    if hasLongitude {
      serialize_size += longitude.computeFloatSize(fieldNumber: 2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBProtoPoint> {
    var mergedArray = Array<PBProtoPoint>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> PBProtoPoint? {
    return try PBProtoPoint.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBProtoPoint.Builder {
    return PBProtoPoint.classBuilder() as! PBProtoPoint.Builder
  }
  public func getBuilder() -> PBProtoPoint.Builder {
    return classBuilder() as! PBProtoPoint.Builder
  }
  override public class func classBuilder() -> MessageBuilder {
    return PBProtoPoint.Builder()
  }
  override public func classBuilder() -> MessageBuilder {
    return PBProtoPoint.Builder()
  }
  public func toBuilder() throws -> PBProtoPoint.Builder {
    return try PBProtoPoint.builderWithPrototype(prototype:self)
  }
  public class func builderWithPrototype(prototype:PBProtoPoint) throws -> PBProtoPoint.Builder {
    return try PBProtoPoint.Builder().mergeFrom(other:prototype)
  }
  override public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasLatitude {
      jsonMap["latitude"] = NSNumber(value:latitude)
    }
    if hasLongitude {
      jsonMap["longitude"] = NSNumber(value:longitude)
    }
    return jsonMap
  }
  override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder.decodeToBuilder(jsonMap:jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder.fromJSONToBuilder(data:data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasLatitude {
      output += "\(indent) latitude: \(latitude) \n"
    }
    if hasLongitude {
      output += "\(indent) longitude: \(longitude) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasLatitude {
             hashCode = (hashCode &* 31) &+ latitude.hashValue
          }
          if hasLongitude {
             hashCode = (hashCode &* 31) &+ longitude.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBProtoPoint"
  }
  override public func className() -> String {
      return "PBProtoPoint"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBProtoPoint.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBProtoPoint = PBProtoPoint()
    public func getMessage() -> PBProtoPoint {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasLatitude:Bool {
         get {
              return builderResult.hasLatitude
         }
    }
    public var latitude:Float {
         get {
              return builderResult.latitude
         }
         set (value) {
             builderResult.hasLatitude = true
             builderResult.latitude = value
         }
    }
    public func setLatitude(_ value:Float) -> PBProtoPoint.Builder {
      self.latitude = value
      return self
    }
    public func clearLatitude() -> PBProtoPoint.Builder{
         builderResult.hasLatitude = false
         builderResult.latitude = Float(0)
         return self
    }
    public var hasLongitude:Bool {
         get {
              return builderResult.hasLongitude
         }
    }
    public var longitude:Float {
         get {
              return builderResult.longitude
         }
         set (value) {
             builderResult.hasLongitude = true
             builderResult.longitude = value
         }
    }
    public func setLongitude(_ value:Float) -> PBProtoPoint.Builder {
      self.longitude = value
      return self
    }
    public func clearLongitude() -> PBProtoPoint.Builder{
         builderResult.hasLongitude = false
         builderResult.longitude = Float(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> PBProtoPoint.Builder {
      builderResult = PBProtoPoint()
      return self
    }
    override public func clone() throws -> PBProtoPoint.Builder {
      return try PBProtoPoint.builderWithPrototype(prototype:builderResult)
    }
    override public func build() throws -> PBProtoPoint {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBProtoPoint {
      let returnMe:PBProtoPoint = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBProtoPoint) throws -> PBProtoPoint.Builder {
      if other == PBProtoPoint() {
       return self
      }
      if other.hasLatitude {
           latitude = other.latitude
      }
      if other.hasLongitude {
           longitude = other.longitude
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PBProtoPoint.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBProtoPoint.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 13:
          latitude = try codedInputStream.readFloat()

        case 21:
          longitude = try codedInputStream.readFloat()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> PBProtoPoint.Builder {
      let resultDecodedBuilder = PBProtoPoint.Builder()
      if let jsonValueLatitude = jsonMap["latitude"] as? NSNumber {
        resultDecodedBuilder.latitude = jsonValueLatitude.floatValue
      }
      if let jsonValueLongitude = jsonMap["longitude"] as? NSNumber {
        resultDecodedBuilder.longitude = jsonValueLongitude.floatValue
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> PBProtoPoint.Builder {
      let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try PBProtoPoint.Builder.decodeToBuilder(jsonMap:jsDataCast)
    }
  }

}

final public class PBIceCreamCone : GeneratedMessage, GeneratedMessageProtocol {


    //Enum type declaration start 

    public enum PBFlavor:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case chocolate = 1
      case vanilla = 2
      public func toString() -> String {
        switch self {
        case .chocolate: return "CHOCOLATE"
        case .vanilla: return "VANILLA"
        }
      }
      public static func fromString(str:String) throws -> PBIceCreamCone.PBFlavor {
        switch str {
        case "CHOCOLATE":  return .chocolate
        case "VANILLA":  return .vanilla
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
        }
      }
      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .chocolate: return ".chocolate"
              case .vanilla: return ".vanilla"
          }
      }
    }

    //Enum type declaration end 

  public private(set) var scoops:Int32 = Int32(0)

  public private(set) var hasScoops:Bool = false
  public private(set) var flavor:PBIceCreamCone.PBFlavor = PBIceCreamCone.PBFlavor.chocolate
  public private(set) var hasFlavor:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream: CodedOutputStream) throws {
    if hasScoops {
      try codedOutputStream.writeInt32(fieldNumber: 1, value:scoops)
    }
    if hasFlavor {
      try codedOutputStream.writeEnum(fieldNumber: 2, value:flavor.rawValue)
    }
    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasScoops {
      serialize_size += scoops.computeInt32Size(fieldNumber: 1)
    }
    if (hasFlavor) {
      serialize_size += flavor.rawValue.computeEnumSize(fieldNumber: 2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBIceCreamCone> {
    var mergedArray = Array<PBIceCreamCone>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> PBIceCreamCone? {
    return try PBIceCreamCone.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBIceCreamCone.Builder {
    return PBIceCreamCone.classBuilder() as! PBIceCreamCone.Builder
  }
  public func getBuilder() -> PBIceCreamCone.Builder {
    return classBuilder() as! PBIceCreamCone.Builder
  }
  override public class func classBuilder() -> MessageBuilder {
    return PBIceCreamCone.Builder()
  }
  override public func classBuilder() -> MessageBuilder {
    return PBIceCreamCone.Builder()
  }
  public func toBuilder() throws -> PBIceCreamCone.Builder {
    return try PBIceCreamCone.builderWithPrototype(prototype:self)
  }
  public class func builderWithPrototype(prototype:PBIceCreamCone) throws -> PBIceCreamCone.Builder {
    return try PBIceCreamCone.Builder().mergeFrom(other:prototype)
  }
  override public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasScoops {
      jsonMap["scoops"] = NSNumber(value:scoops)
    }
    if hasFlavor {
      jsonMap["flavor"] = flavor.toString()
    }
    return jsonMap
  }
  override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder.decodeToBuilder(jsonMap:jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder.fromJSONToBuilder(data:data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasScoops {
      output += "\(indent) scoops: \(scoops) \n"
    }
    if (hasFlavor) {
      output += "\(indent) flavor: \(flavor.description)\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasScoops {
             hashCode = (hashCode &* 31) &+ scoops.hashValue
          }
          if hasFlavor {
             hashCode = (hashCode &* 31) &+ Int(flavor.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBIceCreamCone"
  }
  override public func className() -> String {
      return "PBIceCreamCone"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBIceCreamCone.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBIceCreamCone = PBIceCreamCone()
    public func getMessage() -> PBIceCreamCone {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasScoops:Bool {
         get {
              return builderResult.hasScoops
         }
    }
    public var scoops:Int32 {
         get {
              return builderResult.scoops
         }
         set (value) {
             builderResult.hasScoops = true
             builderResult.scoops = value
         }
    }
    public func setScoops(_ value:Int32) -> PBIceCreamCone.Builder {
      self.scoops = value
      return self
    }
    public func clearScoops() -> PBIceCreamCone.Builder{
         builderResult.hasScoops = false
         builderResult.scoops = Int32(0)
         return self
    }
      public var hasFlavor:Bool{
          get {
              return builderResult.hasFlavor
          }
      }
      public var flavor:PBIceCreamCone.PBFlavor {
          get {
              return builderResult.flavor
          }
          set (value) {
              builderResult.hasFlavor = true
              builderResult.flavor = value
          }
      }
      public func setFlavor(_ value:PBIceCreamCone.PBFlavor) -> PBIceCreamCone.Builder {
        self.flavor = value
        return self
      }
      public func clearFlavor() -> PBIceCreamCone.Builder {
         builderResult.hasFlavor = false
         builderResult.flavor = .chocolate
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> PBIceCreamCone.Builder {
      builderResult = PBIceCreamCone()
      return self
    }
    override public func clone() throws -> PBIceCreamCone.Builder {
      return try PBIceCreamCone.builderWithPrototype(prototype:builderResult)
    }
    override public func build() throws -> PBIceCreamCone {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBIceCreamCone {
      let returnMe:PBIceCreamCone = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBIceCreamCone) throws -> PBIceCreamCone.Builder {
      if other == PBIceCreamCone() {
       return self
      }
      if other.hasScoops {
           scoops = other.scoops
      }
      if other.hasFlavor {
           flavor = other.flavor
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PBIceCreamCone.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBIceCreamCone.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          scoops = try codedInputStream.readInt32()

        case 16:
          let valueIntflavor = try codedInputStream.readEnum()
          if let enumsflavor = PBIceCreamCone.PBFlavor(rawValue:valueIntflavor){
               flavor = enumsflavor
          } else {
               _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntflavor))
          }

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> PBIceCreamCone.Builder {
      let resultDecodedBuilder = PBIceCreamCone.Builder()
      if let jsonValueScoops = jsonMap["scoops"] as? NSNumber {
        resultDecodedBuilder.scoops = jsonValueScoops.int32Value
      }
      if let jsonValueFlavor = jsonMap["flavor"] as? String {
        resultDecodedBuilder.flavor = try PBIceCreamCone.PBFlavor.fromString(str: jsonValueFlavor)
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> PBIceCreamCone.Builder {
      let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try PBIceCreamCone.Builder.decodeToBuilder(jsonMap:jsDataCast)
    }
  }

}

//Subuilders
final public class PBFoo : GeneratedMessage, GeneratedMessageProtocol {
  // some other fields.
  public private(set) var val:Int32 = Int32(0)

  public private(set) var hasVal:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream: CodedOutputStream) throws {
    if hasVal {
      try codedOutputStream.writeInt32(fieldNumber: 1, value:val)
    }
    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasVal {
      serialize_size += val.computeInt32Size(fieldNumber: 1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBFoo> {
    var mergedArray = Array<PBFoo>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> PBFoo? {
    return try PBFoo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> PBFoo {
    return try PBFoo.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBFoo {
    return try PBFoo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> PBFoo {
    return try PBFoo.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBFoo {
    return try PBFoo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> PBFoo {
    return try PBFoo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBFoo {
    return try PBFoo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBFoo.Builder {
    return PBFoo.classBuilder() as! PBFoo.Builder
  }
  public func getBuilder() -> PBFoo.Builder {
    return classBuilder() as! PBFoo.Builder
  }
  override public class func classBuilder() -> MessageBuilder {
    return PBFoo.Builder()
  }
  override public func classBuilder() -> MessageBuilder {
    return PBFoo.Builder()
  }
  public func toBuilder() throws -> PBFoo.Builder {
    return try PBFoo.builderWithPrototype(prototype:self)
  }
  public class func builderWithPrototype(prototype:PBFoo) throws -> PBFoo.Builder {
    return try PBFoo.Builder().mergeFrom(other:prototype)
  }
  override public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasVal {
      jsonMap["val"] = NSNumber(value:val)
    }
    return jsonMap
  }
  override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> PBFoo {
    return try PBFoo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> PBFoo {
    return try PBFoo.Builder.fromJSONToBuilder(data:data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasVal {
      output += "\(indent) val: \(val) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasVal {
             hashCode = (hashCode &* 31) &+ val.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBFoo"
  }
  override public func className() -> String {
      return "PBFoo"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBFoo.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBFoo = PBFoo()
    public func getMessage() -> PBFoo {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasVal:Bool {
         get {
              return builderResult.hasVal
         }
    }
    public var val:Int32 {
         get {
              return builderResult.val
         }
         set (value) {
             builderResult.hasVal = true
             builderResult.val = value
         }
    }
    public func setVal(_ value:Int32) -> PBFoo.Builder {
      self.val = value
      return self
    }
    public func clearVal() -> PBFoo.Builder{
         builderResult.hasVal = false
         builderResult.val = Int32(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> PBFoo.Builder {
      builderResult = PBFoo()
      return self
    }
    override public func clone() throws -> PBFoo.Builder {
      return try PBFoo.builderWithPrototype(prototype:builderResult)
    }
    override public func build() throws -> PBFoo {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBFoo {
      let returnMe:PBFoo = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBFoo) throws -> PBFoo.Builder {
      if other == PBFoo() {
       return self
      }
      if other.hasVal {
           val = other.val
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PBFoo.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBFoo.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          val = try codedInputStream.readInt32()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> PBFoo.Builder {
      let resultDecodedBuilder = PBFoo.Builder()
      if let jsonValueVal = jsonMap["val"] as? NSNumber {
        resultDecodedBuilder.val = jsonValueVal.int32Value
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> PBFoo.Builder {
      let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try PBFoo.Builder.decodeToBuilder(jsonMap:jsDataCast)
    }
  }

}

final public class PBBar : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var foo:PBFoo!
  public private(set) var hasFoo:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream: CodedOutputStream) throws {
    if hasFoo {
      try codedOutputStream.writeMessage(fieldNumber: 1, value:foo)
    }
    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasFoo {
        if let varSizefoo = foo?.computeMessageSize(fieldNumber: 1) {
            serialize_size += varSizefoo
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBBar> {
    var mergedArray = Array<PBBar>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> PBBar? {
    return try PBBar.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> PBBar {
    return try PBBar.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBBar {
    return try PBBar.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> PBBar {
    return try PBBar.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBBar {
    return try PBBar.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> PBBar {
    return try PBBar.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBBar {
    return try PBBar.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBBar.Builder {
    return PBBar.classBuilder() as! PBBar.Builder
  }
  public func getBuilder() -> PBBar.Builder {
    return classBuilder() as! PBBar.Builder
  }
  override public class func classBuilder() -> MessageBuilder {
    return PBBar.Builder()
  }
  override public func classBuilder() -> MessageBuilder {
    return PBBar.Builder()
  }
  public func toBuilder() throws -> PBBar.Builder {
    return try PBBar.builderWithPrototype(prototype:self)
  }
  public class func builderWithPrototype(prototype:PBBar) throws -> PBBar.Builder {
    return try PBBar.Builder().mergeFrom(other:prototype)
  }
  override public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasFoo {
      jsonMap["foo"] = try foo.encode()
    }
    return jsonMap
  }
  override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> PBBar {
    return try PBBar.Builder.decodeToBuilder(jsonMap:jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> PBBar {
    return try PBBar.Builder.fromJSONToBuilder(data:data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasFoo {
      output += "\(indent) foo {\n"
      if let outDescFoo = foo {
        output += try outDescFoo.getDescription(indent: "\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasFoo {
              if let hashValuefoo = foo?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuefoo
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBBar"
  }
  override public func className() -> String {
      return "PBBar"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBBar.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBBar = PBBar()
    public func getMessage() -> PBBar {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasFoo:Bool {
         get {
             return builderResult.hasFoo
         }
    }
    public var foo:PBFoo! {
         get {
             if fooBuilder_ != nil {
                builderResult.foo = fooBuilder_.getMessage()
             }
             return builderResult.foo
         }
         set (value) {
             builderResult.hasFoo = true
             builderResult.foo = value
         }
    }
    private var fooBuilder_:PBFoo.Builder! {
         didSet {
            builderResult.hasFoo = true
         }
    }
    public func getFooBuilder() -> PBFoo.Builder {
      if fooBuilder_ == nil {
         fooBuilder_ = PBFoo.Builder()
         builderResult.foo = fooBuilder_.getMessage()
         if foo != nil {
            _ = try! fooBuilder_.mergeFrom(other: foo)
         }
      }
      return fooBuilder_
    }
    public func setFoo(_ value:PBFoo!) -> PBBar.Builder {
      self.foo = value
      return self
    }
    public func mergeFoo(value:PBFoo) throws -> PBBar.Builder {
      if builderResult.hasFoo {
        builderResult.foo = try PBFoo.builderWithPrototype(prototype:builderResult.foo).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.foo = value
      }
      builderResult.hasFoo = true
      return self
    }
    public func clearFoo() -> PBBar.Builder {
      fooBuilder_ = nil
      builderResult.hasFoo = false
      builderResult.foo = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> PBBar.Builder {
      builderResult = PBBar()
      return self
    }
    override public func clone() throws -> PBBar.Builder {
      return try PBBar.builderWithPrototype(prototype:builderResult)
    }
    override public func build() throws -> PBBar {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBBar {
      let returnMe:PBBar = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBBar) throws -> PBBar.Builder {
      if other == PBBar() {
       return self
      }
      if (other.hasFoo) {
          _ = try mergeFoo(value: other.foo)
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PBBar.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBBar.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:PBFoo.Builder = PBFoo.Builder()
          if hasFoo {
            _ = try subBuilder.mergeFrom(other: foo)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          foo = subBuilder.buildPartial()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> PBBar.Builder {
      let resultDecodedBuilder = PBBar.Builder()
      if let jsonValueFoo = jsonMap["foo"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.foo = try PBFoo.Builder.decodeToBuilder(jsonMap:jsonValueFoo).build()

      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> PBBar.Builder {
      let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try PBBar.Builder.decodeToBuilder(jsonMap:jsDataCast)
    }
  }

}

final public class PBBaz : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var bar:PBBar!
  public private(set) var hasBar:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream: CodedOutputStream) throws {
    if hasBar {
      try codedOutputStream.writeMessage(fieldNumber: 1, value:bar)
    }
    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasBar {
        if let varSizebar = bar?.computeMessageSize(fieldNumber: 1) {
            serialize_size += varSizebar
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBBaz> {
    var mergedArray = Array<PBBaz>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> PBBaz? {
    return try PBBaz.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> PBBaz {
    return try PBBaz.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBBaz {
    return try PBBaz.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> PBBaz {
    return try PBBaz.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBBaz {
    return try PBBaz.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> PBBaz {
    return try PBBaz.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBBaz {
    return try PBBaz.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBBaz.Builder {
    return PBBaz.classBuilder() as! PBBaz.Builder
  }
  public func getBuilder() -> PBBaz.Builder {
    return classBuilder() as! PBBaz.Builder
  }
  override public class func classBuilder() -> MessageBuilder {
    return PBBaz.Builder()
  }
  override public func classBuilder() -> MessageBuilder {
    return PBBaz.Builder()
  }
  public func toBuilder() throws -> PBBaz.Builder {
    return try PBBaz.builderWithPrototype(prototype:self)
  }
  public class func builderWithPrototype(prototype:PBBaz) throws -> PBBaz.Builder {
    return try PBBaz.Builder().mergeFrom(other:prototype)
  }
  override public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasBar {
      jsonMap["bar"] = try bar.encode()
    }
    return jsonMap
  }
  override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> PBBaz {
    return try PBBaz.Builder.decodeToBuilder(jsonMap:jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> PBBaz {
    return try PBBaz.Builder.fromJSONToBuilder(data:data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasBar {
      output += "\(indent) bar {\n"
      if let outDescBar = bar {
        output += try outDescBar.getDescription(indent: "\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBar {
              if let hashValuebar = bar?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuebar
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBBaz"
  }
  override public func className() -> String {
      return "PBBaz"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBBaz.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBBaz = PBBaz()
    public func getMessage() -> PBBaz {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasBar:Bool {
         get {
             return builderResult.hasBar
         }
    }
    public var bar:PBBar! {
         get {
             if barBuilder_ != nil {
                builderResult.bar = barBuilder_.getMessage()
             }
             return builderResult.bar
         }
         set (value) {
             builderResult.hasBar = true
             builderResult.bar = value
         }
    }
    private var barBuilder_:PBBar.Builder! {
         didSet {
            builderResult.hasBar = true
         }
    }
    public func getBarBuilder() -> PBBar.Builder {
      if barBuilder_ == nil {
         barBuilder_ = PBBar.Builder()
         builderResult.bar = barBuilder_.getMessage()
         if bar != nil {
            _ = try! barBuilder_.mergeFrom(other: bar)
         }
      }
      return barBuilder_
    }
    public func setBar(_ value:PBBar!) -> PBBaz.Builder {
      self.bar = value
      return self
    }
    public func mergeBar(value:PBBar) throws -> PBBaz.Builder {
      if builderResult.hasBar {
        builderResult.bar = try PBBar.builderWithPrototype(prototype:builderResult.bar).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.bar = value
      }
      builderResult.hasBar = true
      return self
    }
    public func clearBar() -> PBBaz.Builder {
      barBuilder_ = nil
      builderResult.hasBar = false
      builderResult.bar = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> PBBaz.Builder {
      builderResult = PBBaz()
      return self
    }
    override public func clone() throws -> PBBaz.Builder {
      return try PBBaz.builderWithPrototype(prototype:builderResult)
    }
    override public func build() throws -> PBBaz {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBBaz {
      let returnMe:PBBaz = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBBaz) throws -> PBBaz.Builder {
      if other == PBBaz() {
       return self
      }
      if (other.hasBar) {
          _ = try mergeBar(value: other.bar)
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PBBaz.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBBaz.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:PBBar.Builder = PBBar.Builder()
          if hasBar {
            _ = try subBuilder.mergeFrom(other: bar)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          bar = subBuilder.buildPartial()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> PBBaz.Builder {
      let resultDecodedBuilder = PBBaz.Builder()
      if let jsonValueBar = jsonMap["bar"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.bar = try PBBar.Builder.decodeToBuilder(jsonMap:jsonValueBar).build()

      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> PBBaz.Builder {
      let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try PBBaz.Builder.decodeToBuilder(jsonMap:jsDataCast)
    }
  }

}


// @@protoc_insertion_point(global_scope)
